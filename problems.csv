Category, Level, Number, Name, Notes
array, easy, 408, Valid Word Abbreviation, need two indexes: one to check word and the other for the abbreviation; need also isdigit/isalpha function or ascii char number
array, easy, 387, First Unique Character in a String, use .count() function to solve it but also can use ditionaries for saving counts and then return the only unique char
array, easy, 349, Intersection of Two Arrays, use a dictionary to save first array then make intersection with the second one (can use set data structure)
array, easy, 345, Reverse Vowels of a String, need two indexes: one to start at the array's beginning and one at the end; when idxs are aligned with two vowels you can swap them
array, easy, 434, Number of Segments in a String, check spaces in the array: for each word increment an index; if you find a space continue the loop
array, easy, 268, Missing Number, enumerate all the numbers in the array; subtract index with elem of the array and return the final subtraction
array, easy, 283, Move Zeroes, use two indexes: one called slow for pointing zeroes (increments when the pointer is not pointing zero) and the other called fast that increments every loop; swap when j points != 0 and i points 0
binary_search, easy, 374, Guess Number Higher or Lower, use binary search
binary_search, easy, 278, First Bad Version, use binary search: increment left if the condition is not satisfied or right = mid
hash, easy, 290, Word Pattern, use dictionary to match words in string s with character in pattern; use sets to check the length of unique characters and words
hash, easy, 389, Find the Difference, use dictionary to count the strings and return the elem with value 1
hash, easy, 409, Longest Palindrome, use dictionary to count the number of chars and return the even of all counted number (plus one if we have an odd counted char)
hash, easy, 383, Ransom Note, use two dictionaries to count the occurrencies of the two char strings and then compare them to find the differencies
hash, easy, 13, Roman to Integer, use dictionary to map roman numbers to int numbers; need to check if the next number of the string is greater or not
hash, easy, 415, Add Strings, use two dictionaries to map string numbers to int numbers and viceversa
stacks, easy, 155, Min Stack, stack is a list of tuple (val; min_curr); def __init(self)__: self.list = []; self.list[-1] for taking last elem; for min in costant time you should store and modifiy it when you insert a new num in the stack
stacks, easy, 20, Valid Parentheses, use an array that mimics the stack; save in the stack the open brackets and delete them when you find that the opposite is on the top of the stack
bin, easy, 401, Binary Watch, generate all the times and convert them to two bin number (one for the hour and one for the min); the ones in the bin number are the led you must turn on
bin, easy, 136, Single Number, xor all numbers and return the result
bin, easy, 338, Counting Bits, the num of 1s in a number i = (num of 1s of i//2) + i % 2
bin, easy, 191, Number of 1 Bits, use str(bin(n)).counts("1") or while (n!=0) increment var count and do n = n & (n - 1)
bin, easy, 342, Power of Four, convert to binary and see that a power of four has always one 1 in the leftist digit; the others digits are even 0 (00; 0000; 000000)
hash, easy, 1, Two Sum, use a dictionary to save the pair (number; index); use a variable called x for saving the difference between target and nums[i] and search x in the dict!
hash, easy, 202, Happy Number, loop str(num) for going through all the num's digits; res = (sum all the squared digits) if res == 1 ==> True; else we save the sum in a dict and if we spot that we already have that in our dict ==> False
math, easy, 367, Valid Perfect Square, enumerate from 1 to i*i to find the perfect square;
algorithm, easy, 169, Majority Element, for constant space complex use Boyerâ€“Moore majority algorithm: use a count that increments if the majority==nums[i]; decrement it otherwise; if count==0 ==> majority=nums[i] and count==1
algorithm, easy, 121, Best Time to Buy and Sell Stock, Kadane's algorithm - dynamic prog: one variable stores the answer and another one stores the current sum; at the end of every sum max(ans; cSum); if cSum < 0 ==> cSum==0
bin, medium, 371, Sum of Two Integers, need to use XOR to make sum and AND shifted to the left by 1 to take the carry; repeat until carry is 0; for python only you need to use mask to ensure you have only 32bit
math, medium, 400, Nth digit, calculate how many digits the number has; calculate what the number is; find out which digit in the number is we wanted
